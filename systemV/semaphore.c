#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "semaphore.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Initialize the semaphore set.
 * @details The values of the semaphores in a newly created set are indeterminate.  (POSIX.1-2001 and POSIX.1-2008
 * are explicit  on  this  point,  although  POSIX.1-2008 notes  that  a  future version of the standard
 * may require an implementation to initialize the semaphores to 0.)  Although Linux, like many other implementa‐
 * tions, initializes the semaphore values to 0, a portable application cannot rely on this: it should
 * explicitly initialize the semaphores to the desired  values ---- man of semget()
 * @param key Key generated by ftok()
 * @param nsems Count of semaphore's in the set
 * @param val Initialization value of all the semaphores in the set
 * @return The semaphore-set-id if succeeded, -1 otherwise
 */
int semInit(key_t key, int nsems, int val)
{
    int i;
    union semun arg;
    struct semid_ds buf;
    struct sembuf sb;
    int semid;
    const int MAX_RETRIES = 30;

    semid = semget(key, nsems, IPC_CREAT | IPC_EXCL | 0666);

    if (semid >= 0)
    {
        /*
         * The following lines are doing an explicit initialization (setting semval to 0) on the semaphores' set
         * using semctl().
         */
        arg.array = (unsigned short *)malloc(nsems * sizeof(unsigned short));
        if (arg.array == NULL)
        { /* memory allocation failure */
            int e = errno;
            semctl(semid, 0, IPC_RMID); /* remove the semaphore set */
            errno = e;
            return -1;
        }

        /* set the arg.array's values to 0 */
        memset(arg.array, 0, nsems * sizeof(unsigned short));
        /* manually initialize the semaphore values */
        if (semctl(semid, 0, SETALL, arg) == -1)
        {
            int e = errno;
            semctl(semid, 0, IPC_RMID); /* remove the semaphore set */
            errno = e;
            return -1;
        }
        free(arg.array);
        arg.array = NULL;

        /* do semop() to all the semaphores in the set */
        sb.sem_op = val;
        sb.sem_flg = 0;

        for (sb.sem_num = 0; sb.sem_num < nsems; sb.sem_num++)
        {
            /* do a semop() to "free" the semaphores. */
            /* this sets the sem_otime field (set to non-zero), as needed to ensure the semaphore is initialized. */
            if (semop(semid, &sb, 1) == -1)
            {
                int e = errno;
                semctl(semid, 0, IPC_RMID); /* clean up */
                errno = e;
                return -1; /* error, check errno */
            }
        }
    }
    else if (errno == EEXIST)
    {
        /* Some other process may reach here because of failure to call
         * semget() with IPC_CREAT | IPC_EXCL flags. */
        int ready = 0;

        semid = semget(key, nsems, 0); /* get the id */
        if (semid < 0)
        {
            return -1; /* check errno to get error message */
        }

        /* wait for other process to initialize the semaphore: */
        arg.buf = &buf;
        for (i = 0; i < MAX_RETRIES && !ready; i++)
        {
            /* check semaphore's oparating time to ensure the semaphore set is initialized and ready
             * to call semop() in this concurrent process.
             */
            semctl(semid, nsems - 1, IPC_STAT, arg);
            if (arg.buf->sem_otime != 0)
            {
                ready = 1;
            }
            else
            {
                usleep(100000); /* 0.1 second */
            }
        }
        if (!ready)
        {
            errno = ETIME;
            return -1;
        }
    }
    else
    {
        return -1; /* error, check errno */
    }

    return semid; /* semaphore set is initialized successfully */
}

/**
 * @brief Set a semaphore's value
 * @param semid Semaphore set's id
 * @param semnum Semaphore index in the set
 * @param val Value the semaphore will set to
 * @return 0 if successful, -1 otherwise
 */
int semSetValue(int semid, int semnum, int val)
{
    union semun arg;
    arg.val = val;

    return semctl(semid, semnum, SETVAL, arg);
}

/**
 * @brief Get a semaphore's value
 * @param semid Semaphore set's id
 * @param semnum Semaphore index in the set
 * @return Semaphore's value if successful, -1 otherwise
 */
int semGetValue(int semid, int semnum)
{
    /* semaphore's legal value is always an unsigned short，so if semctl(...GETVAL) returns -1,
    there must be something wrong happens. */
    return semctl(semid, semnum, GETVAL);
}

/**
 * @brief mutex-semaphore pass-check operation 
 *      If the semaphore less than or equal to 0, sem_p() would block
 * @param semid Check on which semaphore
 * @param semnum Semaphore index in the set
 * @return 0 if successful, -1 otherwise
 */
int semP(int semid, int semnum)
{
    struct sembuf sb;
    sb.sem_num = semnum;
    sb.sem_op = -1;
    sb.sem_flg = SEM_UNDO;

    return semop(semid, &sb, 1); /* if error occurs, check errno */
}

/**
     * @brief mutex-semaphore release operation
     *      Increse the semaphore and return immediately
     * @param semid Release on which semaphore
     * @param semnum Semaphore index in the set
     * @return 0 if successful, -1 otherwise
     */
int semV(int semid, int semnum)
{
    struct sembuf sb;
    sb.sem_num = semnum;
    sb.sem_op = 1;
    sb.sem_flg = SEM_UNDO;

    return semop(semid, &sb, 1); /* if error occurs, check errno */
}

/**
 * @brief Remove the semaphore set
 * @param semid Semaphore set's id
 * @return 0 if successful, -1 otherwise
 */
int semRemove(int semid)
{
    return semctl(semid, 0, IPC_RMID);
}

#ifdef __cplusplus
}
#endif
