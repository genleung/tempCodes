#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

#include "bsemaphore.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Initial a binary-value(0/1) semaphore
 * @param key Key generated by ftok()
 * @param val Initialization value of the semaphore
 * @return The semaphore-set-id if succeeded, -1 otherwise
 * */
int bsemInit(key_t key, int val)
{
    return semInit(key, 1, val ? 1 : 0);
}

/**
 * @brief mutex-semaphore pass-check operation
 *      If the semaphore less than or equal to 0, sem_p() would block
 * @param semid Check on which semaphore
 * @return 0 if succeeded, -1 otherwise
 * */
int bsemP(int semid)
{
    struct sembuf sb;
    sb.sem_num = 0;
    sb.sem_op = -1;
    sb.sem_flg = SEM_UNDO;

    return semop(semid, &sb, 1); /* if error occurs, check errno */
}

/**
 * @brief mutex-semaphore release operation
 *      Increse the semaphore and return immediately
 * @param semid Release on which semaphore
 * @return 0 if succeeded, -1 otherwise
 * */
int bsemV(int semid)
{
    struct sembuf sb;
    sb.sem_num = 0;
    sb.sem_op = 1;
    sb.sem_flg = SEM_UNDO;

    return semop(semid, &sb, 1); /* if error occurs, check errno */
}

/**
 * @brief Remove the binary-value(0/1) semaphore
 * @param semid Semaphore set's id
 * @return 0 if successful, -1 otherwise
 */
int bsemRemove(int semid)
{
    return semctl(semid, 0, IPC_RMID);
}

/**
 * @brief Get samaphore's semncnt (man semctl)
 * @param semid Semaphore set's id
 * @return The semaphore's semncnt 
 */
int bsemncnt(int semid)
{
    return semctl(semid, 0, GETNCNT);
}



#ifdef __cplusplus
}
#endif
